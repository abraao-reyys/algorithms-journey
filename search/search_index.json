{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#algorithms-journey","title":"Algorithms Journey","text":""},{"location":"#study-books","title":"Study Books","text":"<p>Here are the books I'm using for my algorithm studies:</p> <ul> <li>Introduction to Algorithms (CLRS) \u2013 The classic reference book for algorithms.</li> </ul> <p>Click on each book to access all related notes.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>This blog is a record of my learning journey in algorithms and programming.</p> <p>My goal is to consolidate concepts, practice writing in English, and create a resource that can be useful to other students.</p>"},{"location":"#about-me","title":"About me","text":"<p>My name is Abra\u00e3o Reis, and I'm an algorithms and computer science enthusiast.</p> <p>I enjoy reading classic books, solving problems, and I'm starting to document the entire learning process.</p>"},{"location":"#contact","title":"Contact","text":"<p>If you want to contact me, you can find me at:</p> <ul> <li>GitHub</li> <li>LinkedIn</li> <li>abraaoreispersonal@gmail.com</li> </ul>"},{"location":"#additional-resources","title":"Additional Resources","text":"<ul> <li>CLRS Official Page</li> <li>My GitHub Repository</li> </ul>"},{"location":"books/clrs/","title":"Introduction to Algorithms","text":"<p>Welcome to notes section of the book Introduction to Algorithms \u2014 CLRS.</p>"},{"location":"books/clrs/#chapters","title":"Chapters","text":"<ul> <li>Chapter 1 - The Role of Algorithms</li> <li>Chapter 2 - Getting Started</li> </ul>"},{"location":"books/clrs/chapter-01/","title":"Chapter 1 - The Role of Algorithms","text":""},{"location":"books/clrs/chapter-01/#11-algorithms","title":"1.1 - Algorithms","text":""},{"location":"books/clrs/chapter-01/#11-1","title":"1.1-1","text":"<p>Sort by top books read.</p>"},{"location":"books/clrs/chapter-01/#11-2","title":"1.1-2","text":"<p>Processing cost, memory usage.</p>"},{"location":"books/clrs/chapter-01/#11-3","title":"1.1-3","text":"<p>Lists: manipulation as a strong point; random access as a weak point.</p>"},{"location":"books/clrs/chapter-01/#11-4","title":"1.1-4","text":"<p>Both look for the shortest path, but differ in restrictions.</p>"},{"location":"books/clrs/chapter-01/#11-5","title":"1.1-5","text":"<ul> <li>Best solution: calculation of important variables</li> <li>Approximate solution: solution for complex equations</li> </ul>"},{"location":"books/clrs/chapter-01/#12-algorithms-as-technology","title":"1.2 - Algorithms as Technology","text":""},{"location":"books/clrs/chapter-01/#12-1","title":"1.2-1","text":"<p>In GPS, we use routes to track our path.</p>"},{"location":"books/clrs/chapter-01/#12-2","title":"1.2-2","text":"<p>8n^2 &lt; 64n lg n n &lt; 8 lg n 2 \u2264 n \u2264 43</p>"},{"location":"books/clrs/chapter-01/#12-3","title":"1.2-3","text":"<p>100n^2 &lt; 2^n n \u2265 15</p>"},{"location":"books/clrs/chapter-01/#1-1-problem","title":"1-1 Problem","text":"1 second 1 minute 1 hour 1 day 1 month 1 year 1 century lg n 2^(10^6) 2^(6*10^7) 2^(3.6*10^9) 2^(8.64*10^10) 2^(2.59*10^12) 2^(3.15*10^13) 2^(3.15*10^15) \u221an 10^12 3.6*10^15 1.3*10^19 7.46*10^21 6.72*10^24 9.95*10^26 9.95*10^30 n 10^6 6*10^7 3.6*10^9 8.64*10^10 2.59*10^12 3.15*10^13 3.15*10^15 n lg n 6.24*10^4 2.8*10^6 1.33*10^8 2.76*10^9 7.19*10^10 7.98*10^11 6.86*10^13 n^2 1000 7745 60000 293938 1609968 5615692 56156922 n^3 100 391 1532 4420 13736 31593 146645 2^n 19 25 31 36 41 44 51 n! 9 11 12 13 15 16 17"},{"location":"books/clrs/chapter-02/","title":"Chapter 2 - Getting Started","text":""},{"location":"books/clrs/chapter-02/#21-insertion-sort","title":"2.1 - Insertion-Sort","text":""},{"location":"books/clrs/chapter-02/#21-1","title":"2.1-1","text":"<p>Example using Java (maybe I prefer it more than pseudocode).</p> <pre><code>import java.util.Arrays;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] stack = {31, 41, 59, 26, 41, 58};\n\n        for (int j = 1; j &lt; stack.length; j++) {\n\n            int key = stack[j];\n            int i = j - 1;\n\n            while(i &gt; -1 &amp;&amp; stack[i] &gt; key) {\n                stack[i + 1] = stack[i];\n                i = i - 1;\n            }\n\n            stack[i + 1] = key;\n        }\n\n        System.out.println(Arrays.toString(stack));\n    }\n}\n</code></pre>"},{"location":"books/clrs/chapter-02/#21-2","title":"2.1-2","text":"<p>Example using Java.</p> <pre><code>import java.util.Arrays;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        int[] stack = {31, 41, 59, 26, 41, 58};\n\n        for (int j = 1; j &lt; stack.length; j++) {\n\n            int key = stack[j];\n            int i = j - 1;\n\n            while(i &gt; -1 &amp;&amp; stack[i] &lt; key) {\n                stack[i + 1] = stack[i];\n                i = i - 1;\n            }\n\n            stack[i + 1] = key;\n        }\n\n        System.out.println(Arrays.toString(stack));\n    }\n}\n</code></pre>"},{"location":"books/clrs/chapter-02/#21-3","title":"2.1-3","text":"<p>Using pseudocode.</p> <pre><code>LINEAR-SEARCH(A, v)\n    for i = 1 to A.length\n        if A[i] == v\n            return i \n    return NIL\n</code></pre> <p>Initialization: before the first iteration, the invariant is true because we have not examined any elements.</p> <p>Maintenance: if the invariant is true at the beginning of an iteration, it remains true after the iteration (or the algorithm returns).</p> <p>Termination: when the loop ends, the invariant guarantees that v is not in <code>A[1..A.length]</code>, so returning NIL is correct.</p>"},{"location":"books/clrs/chapter-02/#21-4","title":"2.1-4","text":"<p>Pending...</p>"},{"location":"books/clrs/chapter-02/#22-algorithms-analysis","title":"2.2 - Algorithms Analysis","text":""},{"location":"books/clrs/chapter-02/#notes","title":"Notes","text":"<p>Analysis from Insertion-Sort</p> <ul> <li> <p>The time depends on input.</p> </li> <li> <p>Sort 1000 items != Sort 3 items.</p> </li> <li> <p>Is tradctional explain the execution time in function of the size input.</p> </li> <li> <p>Size Input: depends on the problem. The measurement is the number of items on input, as n of the Insertion-Sort. Also is possible to be the total number of bits. There are other cases.</p> </li> <li> <p>Execution Time: number of primitive operations or \"steps\" executed. Each step must be the more independent possible. In RAM model, we consider each line with a constant execution time.</p> </li> <li> <p>The execution time of the algorithm is the sum of the execution time for each instruction executed.</p> </li> </ul> <p>Order of Growth</p> <ul> <li> <p>The focus is as the execution time grows; your rate grows.</p> </li> <li> <p>Remove the lowest order terms and constant coefficient of the initial term: an^2 =&gt; \u0398(n^2), tetha notation of the execution time for worst case.</p> </li> <li> <p>An algorithm is more efficient than another if its order of growth is smaller.</p> </li> </ul>"},{"location":"books/clrs/chapter-02/#22-1","title":"2.2-1","text":"<p>Pending...</p>"},{"location":"books/clrs/chapter-02/#22-2","title":"2.2-2","text":"<p>Pending...</p>"},{"location":"books/clrs/chapter-02/#22-3","title":"2.2-3","text":"<p>Pending...</p>"},{"location":"books/clrs/chapter-02/#22-4","title":"2.2-4","text":"<p>Pending...</p>"},{"location":"books/clrs/chapter-02/#23-algorithms-project","title":"2.3 - Algorithms Project","text":""},{"location":"books/clrs/chapter-02/#notes_1","title":"Notes","text":"<p>The Divider to Conquer Approach</p> <ul> <li> <p>There are many recursive algorithms. In general, they follow the \"Divider to Conquer\" approach: break the problem down into smaller problems and then combine the solutions to create a solution to the original problem.</p> </li> <li> <p>Three steps: division, conquer and combination.</p> </li> <li> <p>Here we use the Merge-Sorting.</p> </li> </ul>"},{"location":"posts/initial-post/","title":"Initial Post","text":"<p>At a given moment, before I even entered university, I realized that what I would learn there would not be enough. Therefore, I started looking for alternative ways to learn more.</p> <p>In this moment, I started writing this kind of blog to take notes on the content I learned and complete exercises to better retain the content.</p> <p>Oh, of course. I'm writing in English so I can take advantage of this oportunity and to practice the language.</p>","tags":["notes"]}]}